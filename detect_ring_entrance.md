# detect ring entrance on single-direction linked list

单向链表中是否有环的判别，以及环入口的检测

## 环的检测

如果单链表中存在环，则从头挨个前进的话，会进入无限循环。那么，我们可以利用这个无限循环的特性，来检测出是否有环存在。

1. 定义两个指针，fast 和 slow，初始都指向链表表头；
2. 每次让 slow 指针前进 1 步，让 fast 指针前进 2 步；
3. 如果链表无环，则 fast 指针最终会结束于链表尾部，即： fast 最终指向 NULL；
4. 如果链表有环，则 fast 指针先进入环内循环，slow 指针后进入环内，由于两者存在步差，所以 slow 和 fast 必定在有限步之后相遇；两指针相遇，则检测出有环。

以上步骤为“弗洛伊德算法”，仅可以检测出是否有环，而不知环的起始点在哪里。

## 环入口检测

接下来，我们紧接着上述步骤，寻找环的起点：

1. 在 fast 和 slow 两个指针相遇之后，将 fast 指针重新移动至链表表头，并更改其每步的步长为 1；
2. 同时移动 fast 和 slow 两个指针，直到它们再次相遇，相遇点即为环的起点。

## 入口检测算法证明

假设带环链表由两个部分组成：直链部分，共 m 个节点，环部分，共 n 个节点；

快慢指针分别在进入环之后，跑了 a 圈和 b 圈后相遇，相遇点距离起点 k 个节点;

因此有如下等式成立：

- 慢指针走过的节点数：m + a * n + k
- 快指针走过的节点数：m + b * n + k
- 由于快指针步长是慢指针的两倍，则有 2 * (m + a * n + k) = m + b * n + k

所以化简得： m + 2a * n + k = b * n;

此时两指针距离环的出口的长度（节点数）为：n - k = m + (2a - b + 1) * n，因此，如果此时 slow 指针再走 m 个节点，即落到环的出口处（也就是入口处）。进一步的，m 的值，可以由另一个从头部出发、步长为 1 的指针，同 slow 指针共同指示（两者相遇点即为环的出口/入口）。